(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[4],{

/***/ "./src/public/js/plugins/jquery.custom.js":
/*!************************************************!*\
  !*** ./src/public/js/plugins/jquery.custom.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/*!\r\n * jQuery serializeObject - v0.2 - 1/20/2010\r\n * http://benalman.com/projects/jquery-misc-plugins/\r\n *\r\n * Copyright (c) 2010 \"Cowboy\" Ben Alman\r\n * Dual licensed under the MIT and GPL licenses.\r\n * http://benalman.com/about/license/\r\n */\r\n\r\n// Whereas .serializeArray() serializes a form into an array, .serializeObject()\r\n// serializes a form into an (arguably more useful) object.\r\n\r\n;(function ($, undefined) {\r\n  '$:nomunge' // Used by YUI compressor.\r\n\r\n  $.fn.serializeObject = function () {\r\n    var obj = {}\r\n\r\n    $.each(this.serializeArray(), function (i, o) {\r\n      var n = o.name,\r\n        v = o.value\r\n\r\n      obj[n] = obj[n] === undefined ? v : $.isArray(obj[n]) ? obj[n].concat(v) : [obj[n], v]\r\n    })\r\n\r\n    return obj\r\n  }\r\n\r\n  /**\r\n   This is a jQuery plugin to support resizing text areas.\r\n\r\n   Originally based off text area resizer by Ryan O'Dell : http://plugins.jquery.com/misc/textarea.js\r\n   Modifications by Discourse https://github.com/discourse/discourse\r\n   @module $.fn.DivResizer\r\n   **/\r\n\r\n  var div,\r\n    endDrag,\r\n    grip,\r\n    lastMousePos,\r\n    min,\r\n    mousePosition,\r\n    originalDivHeight,\r\n    originalPos,\r\n    performDrag,\r\n    startDrag,\r\n    wrappedEndDrag,\r\n    wrappedPerformDrag\r\n  div = void 0\r\n  originalPos = void 0\r\n  originalDivHeight = void 0\r\n  lastMousePos = 0\r\n  min = 350\r\n  grip = void 0\r\n  wrappedEndDrag = void 0\r\n  wrappedPerformDrag = void 0\r\n\r\n  startDrag = function (e, opts) {\r\n    div = $(e.data.el)\r\n    div.addClass('clear-transitions')\r\n    div.blur()\r\n    lastMousePos = mousePosition(e).y\r\n    originalPos = lastMousePos\r\n    originalDivHeight = div.height()\r\n    wrappedPerformDrag = (function () {\r\n      return function (e) {\r\n        return performDrag(e, opts)\r\n      }\r\n    })()\r\n    wrappedEndDrag = (function () {\r\n      return function (e) {\r\n        return endDrag(e, opts)\r\n      }\r\n    })()\r\n    $(document)\r\n      .mousemove(wrappedPerformDrag)\r\n      .mouseup(wrappedEndDrag)\r\n    return false\r\n  }\r\n\r\n  performDrag = function (e, opts) {\r\n    $(div).trigger('div-resizing')\r\n\r\n    var size, sizePx, thisMousePos\r\n    thisMousePos = mousePosition(e).y\r\n    size = originalDivHeight + (originalPos - thisMousePos)\r\n    lastMousePos = thisMousePos\r\n\r\n    var maxHeight = $(window).height()\r\n    if (opts.maxHeight) {\r\n      maxHeight = opts.maxHeight(maxHeight)\r\n    }\r\n    size = Math.min(size, maxHeight)\r\n    size = Math.max(min, size)\r\n    sizePx = size + 'px'\r\n    if (typeof opts.onDrag === 'function') {\r\n      opts.onDrag(sizePx)\r\n    }\r\n    div.height(sizePx)\r\n    if (size < min) {\r\n      endDrag(e, opts)\r\n    }\r\n    return false\r\n  }\r\n\r\n  endDrag = function (e, opts) {\r\n    $(document)\r\n      .unbind('mousemove', wrappedPerformDrag)\r\n      .unbind('mouseup', wrappedEndDrag)\r\n    div.removeClass('clear-transitions')\r\n    div.focus()\r\n    if (typeof opts.resize === 'function') {\r\n      opts.resize()\r\n    }\r\n    $(div).trigger('div-resized')\r\n    div = null\r\n  }\r\n\r\n  mousePosition = function (e) {\r\n    return {\r\n      x: e.clientX + document.documentElement.scrollLeft,\r\n      y: e.clientY + document.documentElement.scrollTop\r\n    }\r\n  }\r\n\r\n  $.fn.DivResizer = function (opts) {\r\n    return this.each(function () {\r\n      var grippie, start, staticOffset\r\n      div = $(this)\r\n      if (div.hasClass('processed')) return\r\n      div.addClass('processed')\r\n      staticOffset = null\r\n      start = function () {\r\n        return function (e) {\r\n          return startDrag(e, opts)\r\n        }\r\n      }\r\n      grippie = div\r\n        .prepend(\"<div class='grippie'></div>\")\r\n        .find('.grippie')\r\n        .bind(\r\n          'mousedown',\r\n          {\r\n            el: this\r\n          },\r\n          start()\r\n        )\r\n    })\r\n  }\r\n})(jQuery)\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/plugins/jquery.custom.js?");

/***/ }),

/***/ "./src/public/js/vendor/tomarkdown/tomarkdown.js":
/*!*******************************************************!*\
  !*** ./src/public/js/vendor/tomarkdown/tomarkdown.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;;(function (f) {\n  if (true) {\n    module.exports = f()\n  } else { var g; }\n})(function () {\n  var define, module, exports\n  return (function e (t, n, r) {\n    function s (o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == 'function' && require\n          if (!u && a) return require(o, !0)\n          if (i) return i(o, !0)\n          var f = new Error(\"Cannot find module '\" + o + \"'\")\n          throw ((f.code = 'MODULE_NOT_FOUND'), f)\n        }\n        var l = (n[o] = { exports: {} })\n        t[o][0].call(\n          l.exports,\n          function (e) {\n            var n = t[o][1][e]\n            return s(n ? n : e)\n          },\n          l,\n          l.exports,\n          e,\n          t,\n          n,\n          r\n        )\n      }\n      return n[o].exports\n    }\n    var i = typeof require == 'function' && require\n    for (var o = 0; o < r.length; o++) s(r[o])\n    return s\n  })(\n    {\n      1: [\n        function (require, module, exports) {\n          /*\n           * to-markdown - an HTML to Markdown converter\n           *\n           * Copyright 2011-15, Dom Christie\n           * Licenced under the MIT licence\n           *\n           */\n\n          'use strict'\n\n          var toMarkdown\n          var converters\n          var mdConverters = require('./lib/md-converters')\n          var gfmConverters = require('./lib/gfm-converters')\n          var collapse = require('collapse-whitespace')\n\n          /*\n           * Set up window and document for Node.js\n           */\n\n          var _window = typeof window !== 'undefined' ? window : this,\n            _document\n          if (typeof document === 'undefined') {\n            _document = require('jsdom').jsdom()\n          } else {\n            _document = document\n          }\n\n          /*\n           * Utilities\n           */\n\n          function trim (string) {\n            return string.replace(/^[ \\r\\n\\t]+|[ \\r\\n\\t]+$/g, '')\n          }\n\n          var blocks = [\n            'address',\n            'article',\n            'aside',\n            'audio',\n            'blockquote',\n            'body',\n            'canvas',\n            'center',\n            'dd',\n            'dir',\n            'div',\n            'dl',\n            'dt',\n            'fieldset',\n            'figcaption',\n            'figure',\n            'footer',\n            'form',\n            'frameset',\n            'h1',\n            'h2',\n            'h3',\n            'h4',\n            'h5',\n            'h6',\n            'header',\n            'hgroup',\n            'hr',\n            'html',\n            'isindex',\n            'li',\n            'main',\n            'menu',\n            'nav',\n            'noframes',\n            'noscript',\n            'ol',\n            'output',\n            'p',\n            'pre',\n            'section',\n            'table',\n            'tbody',\n            'td',\n            'tfoot',\n            'th',\n            'thead',\n            'tr',\n            'ul'\n          ]\n\n          function isBlock (node) {\n            return blocks.indexOf(node.nodeName.toLowerCase()) !== -1\n          }\n\n          var voids = [\n            'area',\n            'base',\n            'br',\n            'col',\n            'command',\n            'embed',\n            'hr',\n            'img',\n            'input',\n            'keygen',\n            'link',\n            'meta',\n            'param',\n            'source',\n            'track',\n            'wbr'\n          ]\n\n          function isVoid (node) {\n            return voids.indexOf(node.nodeName.toLowerCase()) !== -1\n          }\n\n          /*\n           * Parsing HTML strings\n           */\n\n          function canParseHtml () {\n            var Parser = _window.DOMParser,\n              canParse = false\n\n            // Adapted from https://gist.github.com/1129031\n            // Firefox/Opera/IE throw errors on unsupported types\n            try {\n              // WebKit returns null on unsupported types\n              if (new Parser().parseFromString('', 'text/html')) {\n                canParse = true\n              }\n            } catch (e) {}\n            return canParse\n          }\n\n          function createHtmlParser () {\n            var Parser = function () {}\n\n            Parser.prototype.parseFromString = function (string) {\n              var newDoc = _document.implementation.createHTMLDocument('')\n\n              if (string.toLowerCase().indexOf('<!doctype') > -1) {\n                newDoc.documentElement.innerHTML = string\n              } else {\n                newDoc.body.innerHTML = string\n              }\n              return newDoc\n            }\n            return Parser\n          }\n\n          var HtmlParser = canParseHtml() ? _window.DOMParser : createHtmlParser()\n\n          function htmlToDom (string) {\n            var tree = new HtmlParser().parseFromString(string, 'text/html')\n            collapse(tree, isBlock)\n            return tree\n          }\n\n          /*\n           * Flattens DOM tree into single array\n           */\n\n          function bfsOrder (node) {\n            var inqueue = [node],\n              outqueue = [],\n              elem,\n              children,\n              i\n\n            while (inqueue.length > 0) {\n              elem = inqueue.shift()\n              outqueue.push(elem)\n              children = elem.childNodes\n              for (i = 0; i < children.length; i++) {\n                if (children[i].nodeType === 1) {\n                  inqueue.push(children[i])\n                }\n              }\n            }\n            outqueue.shift()\n            return outqueue\n          }\n\n          /*\n           * Contructs a Markdown string of replacement text for a given node\n           */\n\n          function getContent (node) {\n            var text = ''\n            for (var i = 0; i < node.childNodes.length; i++) {\n              if (node.childNodes[i].nodeType === 1) {\n                text += node.childNodes[i]._replacement\n              } else if (node.childNodes[i].nodeType === 3) {\n                text += node.childNodes[i].data\n              } else {\n                continue\n              }\n            }\n            return text\n          }\n\n          /*\n           * Returns the HTML string of an element with its contents converted\n           */\n\n          function outer (node, content) {\n            return node.cloneNode(false).outerHTML.replace('><', '>' + content + '<')\n          }\n\n          function canConvert (node, filter) {\n            if (typeof filter === 'string') {\n              return filter === node.nodeName.toLowerCase()\n            }\n            if (Array.isArray(filter)) {\n              return filter.indexOf(node.nodeName.toLowerCase()) !== -1\n            } else if (typeof filter === 'function') {\n              return filter.call(toMarkdown, node)\n            } else {\n              throw new TypeError('`filter` needs to be a string, array, or function')\n            }\n          }\n\n          function isFlankedByWhitespace (side, node) {\n            var sibling, regExp, isFlanked\n\n            if (side === 'left') {\n              sibling = node.previousSibling\n              regExp = / $/\n            } else {\n              sibling = node.nextSibling\n              regExp = /^ /\n            }\n\n            if (sibling) {\n              if (sibling.nodeType === 3) {\n                isFlanked = regExp.test(sibling.nodeValue)\n              } else if (sibling.nodeType === 1 && !isBlock(sibling)) {\n                isFlanked = regExp.test(sibling.textContent)\n              }\n            }\n            return isFlanked\n          }\n\n          function flankingWhitespace (node) {\n            var leading = '',\n              trailing = ''\n\n            if (!isBlock(node)) {\n              var hasLeading = /^[ \\r\\n\\t]/.test(node.innerHTML),\n                hasTrailing = /[ \\r\\n\\t]$/.test(node.innerHTML)\n\n              if (hasLeading && !isFlankedByWhitespace('left', node)) {\n                leading = ' '\n              }\n              if (hasTrailing && !isFlankedByWhitespace('right', node)) {\n                trailing = ' '\n              }\n            }\n\n            return { leading: leading, trailing: trailing }\n          }\n\n          /*\n           * Finds a Markdown converter, gets the replacement, and sets it on\n           * `_replacement`\n           */\n\n          function process (node) {\n            var replacement,\n              content = getContent(node)\n\n            for (var i = 0; i < converters.length; i++) {\n              var converter = converters[i]\n\n              if (canConvert(node, converter.filter)) {\n                if (typeof converter.replacement !== 'function') {\n                  throw new TypeError('`replacement` needs to be a function that returns a string')\n                }\n\n                var whitespace = flankingWhitespace(node)\n\n                if (whitespace.leading || whitespace.trailing) {\n                  content = trim(content)\n                }\n                replacement =\n                  whitespace.leading + converter.replacement.call(toMarkdown, content, node) + whitespace.trailing\n                break\n              }\n            }\n\n            // Remove blank nodes\n            if (!isVoid(node) && !/A/.test(node.nodeName) && /^\\s*$/i.test(content)) {\n              replacement = ''\n            }\n\n            node._replacement = replacement\n          }\n\n          toMarkdown = function (input, options) {\n            options = options || {}\n\n            if (typeof input !== 'string') {\n              throw new TypeError(input + ' is not a string')\n            }\n\n            // Escape potential ol triggers\n            input = input.replace(/(\\d+)\\. /g, '$1\\\\. ')\n\n            var clone = htmlToDom(input).body,\n              nodes = bfsOrder(clone),\n              output\n\n            converters = mdConverters.slice(0)\n            if (options.gfm) {\n              converters = gfmConverters.concat(converters)\n            }\n\n            if (options.converters) {\n              converters = options.converters.concat(converters)\n            }\n\n            // Process through nodes in reverse (so deepest child elements are first).\n            for (var i = nodes.length - 1; i >= 0; i--) {\n              process(nodes[i])\n            }\n            output = getContent(clone)\n\n            return output\n              .replace(/^[\\t\\r\\n]+|[\\t\\r\\n\\s]+$/g, '')\n              .replace(/\\n\\s+\\n/g, '\\n\\n')\n              .replace(/\\n{3,}/g, '\\n\\n')\n          }\n\n          toMarkdown.isBlock = isBlock\n          toMarkdown.isVoid = isVoid\n          toMarkdown.trim = trim\n          toMarkdown.outer = outer\n\n          module.exports = toMarkdown\n        },\n        { './lib/gfm-converters': 2, './lib/md-converters': 3, 'collapse-whitespace': 5, jsdom: 6 }\n      ],\n      2: [\n        function (require, module, exports) {\n          'use strict'\n\n          function cell (content, node) {\n            var index = Array.prototype.indexOf.call(node.parentNode.childNodes, node)\n            var prefix = ' '\n            if (index === 0) {\n              prefix = '| '\n            }\n            return prefix + content + ' |'\n          }\n\n          var highlightRegEx = /highlight highlight-(\\S+)/\n\n          module.exports = [\n            {\n              filter: 'br',\n              replacement: function () {\n                return '\\n'\n              }\n            },\n            {\n              filter: ['del', 's', 'strike'],\n              replacement: function (content) {\n                return '~~' + content + '~~'\n              }\n            },\n\n            {\n              filter: function (node) {\n                return node.type === 'checkbox' && node.parentNode.nodeName === 'LI'\n              },\n              replacement: function (content, node) {\n                return (node.checked ? '[x]' : '[ ]') + ' '\n              }\n            },\n\n            {\n              filter: ['th', 'td'],\n              replacement: function (content, node) {\n                return cell(content, node)\n              }\n            },\n\n            {\n              filter: 'tr',\n              replacement: function (content, node) {\n                var borderCells = ''\n                var alignMap = { left: ':--', right: '--:', center: ':-:' }\n\n                if (node.parentNode.nodeName === 'THEAD') {\n                  for (var i = 0; i < node.childNodes.length; i++) {\n                    var align = node.childNodes[i].attributes.align\n                    var border = '---'\n\n                    if (align) {\n                      border = alignMap[align.value] || border\n                    }\n\n                    borderCells += cell(border, node.childNodes[i])\n                  }\n                }\n                return '\\n' + content + (borderCells ? '\\n' + borderCells : '')\n              }\n            },\n\n            {\n              filter: 'table',\n              replacement: function (content) {\n                return '\\n\\n' + content + '\\n\\n'\n              }\n            },\n\n            {\n              filter: ['thead', 'tbody', 'tfoot'],\n              replacement: function (content) {\n                return content\n              }\n            },\n\n            // Fenced code blocks\n            {\n              filter: function (node) {\n                return node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE'\n              },\n              replacement: function (content, node) {\n                return '\\n\\n```\\n' + node.firstChild.textContent + '\\n```\\n\\n'\n              }\n            },\n\n            // Syntax-highlighted code blocks\n            {\n              filter: function (node) {\n                return (\n                  node.nodeName === 'PRE' &&\n                  node.parentNode.nodeName === 'DIV' &&\n                  highlightRegEx.test(node.parentNode.className)\n                )\n              },\n              replacement: function (content, node) {\n                var language = node.parentNode.className.match(highlightRegEx)[1]\n                return '\\n\\n```' + language + '\\n' + node.textContent + '\\n```\\n\\n'\n              }\n            },\n\n            {\n              filter: function (node) {\n                return node.nodeName === 'DIV' && highlightRegEx.test(node.className)\n              },\n              replacement: function (content) {\n                return '\\n\\n' + content + '\\n\\n'\n              }\n            }\n          ]\n        },\n        {}\n      ],\n      3: [\n        function (require, module, exports) {\n          'use strict'\n\n          module.exports = [\n            {\n              filter: 'p',\n              replacement: function (content) {\n                return '\\n\\n' + content + '\\n\\n'\n              }\n            },\n\n            {\n              filter: 'br',\n              replacement: function () {\n                return '  \\n'\n              }\n            },\n\n            {\n              filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n              replacement: function (content, node) {\n                var hLevel = node.nodeName.charAt(1)\n                var hPrefix = ''\n                for (var i = 0; i < hLevel; i++) {\n                  hPrefix += '#'\n                }\n                return '\\n\\n' + hPrefix + ' ' + content + '\\n\\n'\n              }\n            },\n\n            {\n              filter: 'hr',\n              replacement: function () {\n                return '\\n\\n* * *\\n\\n'\n              }\n            },\n\n            {\n              filter: ['em', 'i'],\n              replacement: function (content) {\n                return '_' + content + '_'\n              }\n            },\n\n            {\n              filter: ['strong', 'b'],\n              replacement: function (content) {\n                return '**' + content + '**'\n              }\n            },\n\n            // Inline code\n            {\n              filter: function (node) {\n                var hasSiblings = node.previousSibling || node.nextSibling\n                var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings\n\n                return node.nodeName === 'CODE' && !isCodeBlock\n              },\n              replacement: function (content) {\n                return '`' + content + '`'\n              }\n            },\n\n            {\n              filter: function (node) {\n                return node.nodeName === 'A' && node.getAttribute('href')\n              },\n              replacement: function (content, node) {\n                var titlePart = node.title ? ' \"' + node.title + '\"' : ''\n                return '[' + content + '](' + node.getAttribute('href') + titlePart + ')'\n              }\n            },\n\n            {\n              filter: 'img',\n              replacement: function (content, node) {\n                var alt = node.alt || ''\n                var src = node.getAttribute('src') || ''\n                var title = node.title || ''\n                var titlePart = title ? ' \"' + title + '\"' : ''\n                return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : ''\n              }\n            },\n\n            // Code blocks\n            {\n              filter: function (node) {\n                return node.nodeName === 'PRE' && node.firstChild.nodeName === 'CODE'\n              },\n              replacement: function (content, node) {\n                return '\\n\\n    ' + node.firstChild.textContent.replace(/\\n/g, '\\n    ') + '\\n\\n'\n              }\n            },\n\n            {\n              filter: 'blockquote',\n              replacement: function (content) {\n                content = this.trim(content)\n                content = content.replace(/\\n{3,}/g, '\\n\\n')\n                content = content.replace(/^/gm, '> ')\n                return '\\n\\n' + content + '\\n\\n'\n              }\n            },\n\n            {\n              filter: 'li',\n              replacement: function (content, node) {\n                content = content.replace(/^\\s+/, '').replace(/\\n/gm, '\\n    ')\n                var prefix = '*   '\n                var parent = node.parentNode\n                var index = Array.prototype.indexOf.call(parent.children, node) + 1\n\n                prefix = /ol/i.test(parent.nodeName) ? index + '.  ' : '*   '\n                return prefix + content\n              }\n            },\n\n            {\n              filter: ['ul', 'ol'],\n              replacement: function (content, node) {\n                var strings = []\n                for (var i = 0; i < node.childNodes.length; i++) {\n                  strings.push(node.childNodes[i]._replacement)\n                }\n\n                if (/li/i.test(node.parentNode.nodeName)) {\n                  return '\\n' + strings.join('\\n')\n                }\n                return '\\n\\n' + strings.join('\\n') + '\\n\\n'\n              }\n            },\n\n            {\n              filter: function (node) {\n                return this.isBlock(node)\n              },\n              replacement: function (content, node) {\n                return '\\n\\n' + this.outer(node, content) + '\\n\\n'\n              }\n            },\n\n            // Anything else!\n            {\n              filter: function () {\n                return true\n              },\n              replacement: function (content, node) {\n                return this.outer(node, content)\n              }\n            }\n          ]\n        },\n        {}\n      ],\n      4: [\n        function (require, module, exports) {\n          /**\n           * This file automatically generated from `build.js`.\n           * Do not manually edit.\n           */\n\n          module.exports = [\n            'address',\n            'article',\n            'aside',\n            'audio',\n            'blockquote',\n            'canvas',\n            'dd',\n            'div',\n            'dl',\n            'fieldset',\n            'figcaption',\n            'figure',\n            'footer',\n            'form',\n            'h1',\n            'h2',\n            'h3',\n            'h4',\n            'h5',\n            'h6',\n            'header',\n            'hgroup',\n            'hr',\n            'noscript',\n            'ol',\n            'output',\n            'p',\n            'pre',\n            'section',\n            'table',\n            'tfoot',\n            'ul',\n            'video'\n          ]\n        },\n        {}\n      ],\n      5: [\n        function (require, module, exports) {\n          'use strict'\n\n          var blocks = require('block-elements').map(function (name) {\n            return name.toUpperCase()\n          })\n\n          function defaultBlockTest (node) {\n            return isElem(node) && blocks.indexOf(node.nodeName) >= 0\n          }\n\n          function isText (node) {\n            return node && node.nodeType === 3 // Node.TEXT_NODE\n          }\n\n          function isElem (node) {\n            return node && node.nodeType === 1 // Node.ELEMENT_NODE\n          }\n\n          /**\n           * whitespace(elem [, isBlock]) removes extraneous whitespace from an\n           * the given element. The function isBlock may optionally be passed in\n           * to determine whether or not an element is a block element; if none\n           * is provided, defaults to using the list of block elements provided\n           * by the `block-elements` module.\n           *\n           * @param {Element} root\n           * @param {Function} isBlock\n           */\n          function whitespace (root, isBlock) {\n            var startSpace = /^ /,\n              endSpace = / $/,\n              nextNode,\n              prevNode,\n              prevText,\n              node,\n              text\n\n            if (typeof isBlock !== 'function') isBlock = defaultBlockTest\n\n            function next (node) {\n              while (node && node !== root) {\n                if (node.nextSibling) return node.nextSibling\n\n                node = node.parentNode\n                if (prevText && isBlock(node)) {\n                  prevText.data = prevText.data.replace(/[ \\r\\n\\t]$/, '')\n                  prevText = null\n                }\n              }\n\n              return null\n            }\n\n            function first (node) {\n              return node.firstChild ? node.firstChild : next(node)\n            }\n\n            function remove (node) {\n              var nextNode = next(node)\n\n              node.parentNode.removeChild(node)\n              return nextNode\n            }\n\n            if (root.nodeName === 'PRE') return\n\n            // Join adjacent text nodes and whatnot.\n            root.normalize()\n\n            node = first(root)\n            while (node) {\n              prevNode = node.previousSibling\n              nextNode = node.nextSibling\n\n              if (isText(node)) {\n                text = node.data.replace(/[ \\r\\n\\t]+/g, ' ')\n\n                if (!prevText || (prevNode && isBlock(prevNode))) text = text.replace(startSpace, '')\n                if (nextNode && isBlock(nextNode)) text = text.replace(endSpace, '')\n\n                if (prevText && endSpace.test(prevText.data) && startSpace.test(text)) text = text.substr(1)\n\n                if (text) {\n                  node.data = text\n                  prevText = node\n                  node = next(node)\n                } else {\n                  node = remove(node)\n                }\n              } else if (isElem(node)) {\n                if (node.nodeName === 'PRE') {\n                  node = next(node)\n                  continue\n                }\n\n                if (prevText && isBlock(node)) {\n                  prevText.data = prevText.data.replace(endSpace, '')\n                  prevText = null\n                }\n\n                node = first(node)\n              } else {\n                node = remove(node)\n              }\n            }\n\n            // Trim trailing space from last text node\n            if (prevText) prevText.data = prevText.data.replace(endSpace, '')\n          }\n\n          module.exports = whitespace\n        },\n        { 'block-elements': 4 }\n      ],\n      6: [function (require, module, exports) {}, {}]\n    },\n    {},\n    [1]\n  )(1)\n})\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/tomarkdown/tomarkdown.js?");

/***/ })

}]);